<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArcsSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.geometry.spherical.oned</a> &gt; <span class="el_source">ArcsSet.java</span></div><h1>ArcsSet.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math3.geometry.spherical.oned;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

import org.apache.commons.math3.exception.MathIllegalArgumentException;
import org.apache.commons.math3.exception.MathInternalError;
import org.apache.commons.math3.exception.NumberIsTooLargeException;
import org.apache.commons.math3.exception.util.LocalizedFormats;
import org.apache.commons.math3.geometry.Point;
import org.apache.commons.math3.geometry.partitioning.AbstractRegion;
import org.apache.commons.math3.geometry.partitioning.BSPTree;
import org.apache.commons.math3.geometry.partitioning.BoundaryProjection;
import org.apache.commons.math3.geometry.partitioning.Side;
import org.apache.commons.math3.geometry.partitioning.SubHyperplane;
import org.apache.commons.math3.util.FastMath;
import org.apache.commons.math3.util.MathUtils;
import org.apache.commons.math3.util.Precision;

/** This class represents a region of a circle: a set of arcs.
 * &lt;p&gt;
 * Note that due to the wrapping around \(2 \pi\), barycenter is
 * ill-defined here. It was defined only in order to fulfill
 * the requirements of the {@link
 * org.apache.commons.math3.geometry.partitioning.Region Region}
 * interface, but its use is discouraged.
 * &lt;/p&gt;
 * @since 3.3
 */
public class ArcsSet extends AbstractRegion&lt;Sphere1D, Sphere1D&gt; implements Iterable&lt;double[]&gt; {

    /** Build an arcs set representing the whole circle.
     * @param tolerance tolerance below which close sub-arcs are merged together
     */
    public ArcsSet(final double tolerance) {
<span class="fc" id="L55">        super(tolerance);</span>
<span class="fc" id="L56">    }</span>

    /** Build an arcs set corresponding to a single arc.
     * &lt;p&gt;
     * If either {@code lower} is equals to {@code upper} or
     * the interval exceeds \( 2 \pi \), the arc is considered
     * to be the full circle and its initial defining boundaries
     * will be forgotten. {@code lower} is not allowed to be greater
     * than {@code upper} (an exception is thrown in this case).
     * &lt;/p&gt;
     * @param lower lower bound of the arc
     * @param upper upper bound of the arc
     * @param tolerance tolerance below which close sub-arcs are merged together
     * @exception NumberIsTooLargeException if lower is greater than upper
     */
    public ArcsSet(final double lower, final double upper, final double tolerance)
        throws NumberIsTooLargeException {
<span class="fc" id="L73">        super(buildTree(lower, upper, tolerance), tolerance);</span>
<span class="fc" id="L74">    }</span>

    /** Build an arcs set from an inside/outside BSP tree.
     * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a
     * {@code Boolean} attribute representing the inside status of
     * the corresponding cell (true for inside cells, false for outside
     * cells). In order to avoid building too many small objects, it is
     * recommended to use the predefined constants
     * {@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;
     * @param tree inside/outside BSP tree representing the arcs set
     * @param tolerance tolerance below which close sub-arcs are merged together
     * @exception InconsistentStateAt2PiWrapping if the tree leaf nodes are not
     * consistent across the \( 0, 2 \pi \) crossing
     */
    public ArcsSet(final BSPTree&lt;Sphere1D&gt; tree, final double tolerance)
        throws InconsistentStateAt2PiWrapping {
<span class="fc" id="L90">        super(tree, tolerance);</span>
<span class="fc" id="L91">        check2PiConsistency();</span>
<span class="fc" id="L92">    }</span>

    /** Build an arcs set from a Boundary REPresentation (B-rep).
     * &lt;p&gt;The boundary is provided as a collection of {@link
     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
     * interior part of the region on its minus side and the exterior on
     * its plus side.&lt;/p&gt;
     * &lt;p&gt;The boundary elements can be in any order, and can form
     * several non-connected sets (like for example polygons with holes
     * or a set of disjoints polyhedrons considered as a whole). In
     * fact, the elements do not even need to be connected together
     * (their topological connections are not used here). However, if the
     * boundary does not really separate an inside open from an outside
     * open (open having here its topological meaning), then subsequent
     * calls to the {@link
     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Point)
     * checkPoint} method will not be meaningful anymore.&lt;/p&gt;
     * &lt;p&gt;If the boundary is empty, the region will represent the whole
     * space.&lt;/p&gt;
     * @param boundary collection of boundary elements
     * @param tolerance tolerance below which close sub-arcs are merged together
     * @exception InconsistentStateAt2PiWrapping if the tree leaf nodes are not
     * consistent across the \( 0, 2 \pi \) crossing
     */
    public ArcsSet(final Collection&lt;SubHyperplane&lt;Sphere1D&gt;&gt; boundary, final double tolerance)
        throws InconsistentStateAt2PiWrapping {
<span class="fc" id="L118">        super(boundary, tolerance);</span>
<span class="fc" id="L119">        check2PiConsistency();</span>
<span class="fc" id="L120">    }</span>

    /** Build an inside/outside tree representing a single arc.
     * @param lower lower angular bound of the arc
     * @param upper upper angular bound of the arc
     * @param tolerance tolerance below which close sub-arcs are merged together
     * @return the built tree
     * @exception NumberIsTooLargeException if lower is greater than upper
     */
    private static BSPTree&lt;Sphere1D&gt; buildTree(final double lower, final double upper,
                                               final double tolerance)
        throws NumberIsTooLargeException {

<span class="pc bpc" id="L133" title="1 of 4 branches missed.">        if (Precision.equals(lower, upper, 0) || (upper - lower) &gt;= MathUtils.TWO_PI) {</span>
            // the tree must cover the whole circle
<span class="fc" id="L135">            return new BSPTree&lt;Sphere1D&gt;(Boolean.TRUE);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">        } else  if (lower &gt; upper) {</span>
<span class="fc" id="L137">            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,</span>
<span class="fc" id="L138">                                                lower, upper, true);</span>
        }

        // this is a regular arc, covering only part of the circle
<span class="fc" id="L142">        final double normalizedLower = MathUtils.normalizeAngle(lower, FastMath.PI);</span>
<span class="fc" id="L143">        final double normalizedUpper = normalizedLower + (upper - lower);</span>
<span class="fc" id="L144">        final SubHyperplane&lt;Sphere1D&gt; lowerCut =</span>
<span class="fc" id="L145">                new LimitAngle(new S1Point(normalizedLower), false, tolerance).wholeHyperplane();</span>

<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (normalizedUpper &lt;= MathUtils.TWO_PI) {</span>
            // simple arc starting after 0 and ending before 2 \pi
<span class="fc" id="L149">            final SubHyperplane&lt;Sphere1D&gt; upperCut =</span>
<span class="fc" id="L150">                    new LimitAngle(new S1Point(normalizedUpper), true, tolerance).wholeHyperplane();</span>
<span class="fc" id="L151">            return new BSPTree&lt;Sphere1D&gt;(lowerCut,</span>
<span class="fc" id="L152">                                         new BSPTree&lt;Sphere1D&gt;(Boolean.FALSE),</span>
<span class="fc" id="L153">                                         new BSPTree&lt;Sphere1D&gt;(upperCut,</span>
<span class="fc" id="L154">                                                               new BSPTree&lt;Sphere1D&gt;(Boolean.FALSE),</span>
<span class="fc" id="L155">                                                               new BSPTree&lt;Sphere1D&gt;(Boolean.TRUE),</span>
<span class="fc" id="L156">                                                               null),</span>
<span class="fc" id="L157">                                         null);</span>
        } else {
            // arc wrapping around 2 \pi
<span class="fc" id="L160">            final SubHyperplane&lt;Sphere1D&gt; upperCut =</span>
<span class="fc" id="L161">                    new LimitAngle(new S1Point(normalizedUpper - MathUtils.TWO_PI), true, tolerance).wholeHyperplane();</span>
<span class="fc" id="L162">            return new BSPTree&lt;Sphere1D&gt;(lowerCut,</span>
<span class="fc" id="L163">                                         new BSPTree&lt;Sphere1D&gt;(upperCut,</span>
<span class="fc" id="L164">                                                               new BSPTree&lt;Sphere1D&gt;(Boolean.FALSE),</span>
<span class="fc" id="L165">                                                               new BSPTree&lt;Sphere1D&gt;(Boolean.TRUE),</span>
<span class="fc" id="L166">                                                               null),</span>
<span class="fc" id="L167">                                         new BSPTree&lt;Sphere1D&gt;(Boolean.TRUE),</span>
<span class="fc" id="L168">                                         null);</span>
        }

    }

    /** Check consistency.
    * @exception InconsistentStateAt2PiWrapping if the tree leaf nodes are not
    * consistent across the \( 0, 2 \pi \) crossing
    */
    private void check2PiConsistency() throws InconsistentStateAt2PiWrapping {

        // start search at the tree root
<span class="fc" id="L180">        BSPTree&lt;Sphere1D&gt; root = getTree(false);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (root.getCut() == null) {</span>
<span class="fc" id="L182">            return;</span>
        }

        // find the inside/outside state before the smallest internal node
<span class="fc" id="L186">        final Boolean stateBefore = (Boolean) getFirstLeaf(root).getAttribute();</span>

        // find the inside/outside state after the largest internal node
<span class="fc" id="L189">        final Boolean stateAfter = (Boolean) getLastLeaf(root).getAttribute();</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (stateBefore ^ stateAfter) {</span>
<span class="fc" id="L192">            throw new InconsistentStateAt2PiWrapping();</span>
        }

<span class="fc" id="L195">    }</span>

    /** Get the first leaf node of a tree.
     * @param root tree root
     * @return first leaf node (i.e. node corresponding to the region just after 0.0 radians)
     */
    private BSPTree&lt;Sphere1D&gt; getFirstLeaf(final BSPTree&lt;Sphere1D&gt; root) {

<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (root.getCut() == null) {</span>
<span class="fc" id="L204">            return root;</span>
        }

        // find the smallest internal node
<span class="fc" id="L208">        BSPTree&lt;Sphere1D&gt; smallest = null;</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (BSPTree&lt;Sphere1D&gt; n = root; n != null; n = previousInternalNode(n)) {</span>
<span class="fc" id="L210">            smallest = n;</span>
        }

<span class="fc" id="L213">        return leafBefore(smallest);</span>

    }

    /** Get the last leaf node of a tree.
     * @param root tree root
     * @return last leaf node (i.e. node corresponding to the region just before \( 2 \pi \) radians)
     */
    private BSPTree&lt;Sphere1D&gt; getLastLeaf(final BSPTree&lt;Sphere1D&gt; root) {

<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (root.getCut() == null) {</span>
<span class="nc" id="L224">            return root;</span>
        }

        // find the largest internal node
<span class="fc" id="L228">        BSPTree&lt;Sphere1D&gt; largest = null;</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        for (BSPTree&lt;Sphere1D&gt; n = root; n != null; n = nextInternalNode(n)) {</span>
<span class="fc" id="L230">            largest = n;</span>
        }

<span class="fc" id="L233">        return leafAfter(largest);</span>

    }

    /** Get the node corresponding to the first arc start.
     * @return smallest internal node (i.e. first after 0.0 radians, in trigonometric direction),
     * or null if there are no internal nodes (i.e. the set is either empty or covers the full circle)
     */
    private BSPTree&lt;Sphere1D&gt; getFirstArcStart() {

        // start search at the tree root
<span class="fc" id="L244">        BSPTree&lt;Sphere1D&gt; node = getTree(false);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if (node.getCut() == null) {</span>
<span class="fc" id="L246">            return null;</span>
        }

        // walk tree until we find the smallest internal node
<span class="fc" id="L250">        node = getFirstLeaf(node).getParent();</span>

        // walk tree until we find an arc start
<span class="pc bpc" id="L253" title="1 of 4 branches missed.">        while (node != null &amp;&amp; !isArcStart(node)) {</span>
<span class="fc" id="L254">            node = nextInternalNode(node);</span>
        }

<span class="fc" id="L257">        return node;</span>

    }

    /** Check if an internal node corresponds to the start angle of an arc.
     * @param node internal node to check
     * @return true if the node corresponds to the start angle of an arc
     */
    private boolean isArcStart(final BSPTree&lt;Sphere1D&gt; node) {

<span class="fc bfc" id="L267" title="All 2 branches covered.">        if ((Boolean) leafBefore(node).getAttribute()) {</span>
            // it has an inside cell before it, it may end an arc but not start it
<span class="fc" id="L269">            return false;</span>
        }

<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (!(Boolean) leafAfter(node).getAttribute()) {</span>
            // it has an outside cell after it, it is a dummy cut away from real arcs
<span class="fc" id="L274">            return false;</span>
        }

        // the cell has an outside before and an inside after it
        // it is the start of an arc
<span class="fc" id="L279">        return true;</span>

    }

    /** Check if an internal node corresponds to the end angle of an arc.
     * @param node internal node to check
     * @return true if the node corresponds to the end angle of an arc
     */
    private boolean isArcEnd(final BSPTree&lt;Sphere1D&gt; node) {

<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (!(Boolean) leafBefore(node).getAttribute()) {</span>
            // it has an outside cell before it, it may start an arc but not end it
<span class="fc" id="L291">            return false;</span>
        }

<span class="fc bfc" id="L294" title="All 2 branches covered.">        if ((Boolean) leafAfter(node).getAttribute()) {</span>
            // it has an inside cell after it, it is a dummy cut in the middle of an arc
<span class="fc" id="L296">            return false;</span>
        }

        // the cell has an inside before and an outside after it
        // it is the end of an arc
<span class="fc" id="L301">        return true;</span>

    }

    /** Get the next internal node.
     * @param node current internal node
     * @return next internal node in trigonometric order, or null
     * if this is the last internal node
     */
    private BSPTree&lt;Sphere1D&gt; nextInternalNode(BSPTree&lt;Sphere1D&gt; node) {

<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (childAfter(node).getCut() != null) {</span>
            // the next node is in the sub-tree
<span class="fc" id="L314">            return leafAfter(node).getParent();</span>
        }

        // there is nothing left deeper in the tree, we backtrack
<span class="fc bfc" id="L318" title="All 2 branches covered.">        while (isAfterParent(node)) {</span>
<span class="fc" id="L319">            node = node.getParent();</span>
        }
<span class="fc" id="L321">        return node.getParent();</span>

    }

    /** Get the previous internal node.
     * @param node current internal node
     * @return previous internal node in trigonometric order, or null
     * if this is the first internal node
     */
    private BSPTree&lt;Sphere1D&gt; previousInternalNode(BSPTree&lt;Sphere1D&gt; node) {

<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (childBefore(node).getCut() != null) {</span>
            // the next node is in the sub-tree
<span class="fc" id="L334">            return leafBefore(node).getParent();</span>
        }

        // there is nothing left deeper in the tree, we backtrack
<span class="fc bfc" id="L338" title="All 2 branches covered.">        while (isBeforeParent(node)) {</span>
<span class="fc" id="L339">            node = node.getParent();</span>
        }
<span class="fc" id="L341">        return node.getParent();</span>

    }

    /** Find the leaf node just before an internal node.
     * @param node internal node at which the sub-tree starts
     * @return leaf node just before the internal node
     */
    private BSPTree&lt;Sphere1D&gt; leafBefore(BSPTree&lt;Sphere1D&gt; node) {

<span class="fc" id="L351">        node = childBefore(node);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        while (node.getCut() != null) {</span>
<span class="fc" id="L353">            node = childAfter(node);</span>
        }

<span class="fc" id="L356">        return node;</span>

    }

    /** Find the leaf node just after an internal node.
     * @param node internal node at which the sub-tree starts
     * @return leaf node just after the internal node
     */
    private BSPTree&lt;Sphere1D&gt; leafAfter(BSPTree&lt;Sphere1D&gt; node) {

<span class="fc" id="L366">        node = childAfter(node);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        while (node.getCut() != null) {</span>
<span class="fc" id="L368">            node = childBefore(node);</span>
        }

<span class="fc" id="L371">        return node;</span>

    }

    /** Check if a node is the child before its parent in trigonometric order.
     * @param node child node considered
     * @return true is the node has a parent end is before it in trigonometric order
     */
    private boolean isBeforeParent(final BSPTree&lt;Sphere1D&gt; node) {
<span class="fc" id="L380">        final BSPTree&lt;Sphere1D&gt; parent = node.getParent();</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (parent == null) {</span>
<span class="fc" id="L382">            return false;</span>
        } else {
<span class="fc bfc" id="L384" title="All 2 branches covered.">            return node == childBefore(parent);</span>
        }
    }

    /** Check if a node is the child after its parent in trigonometric order.
     * @param node child node considered
     * @return true is the node has a parent end is after it in trigonometric order
     */
    private boolean isAfterParent(final BSPTree&lt;Sphere1D&gt; node) {
<span class="fc" id="L393">        final BSPTree&lt;Sphere1D&gt; parent = node.getParent();</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (parent == null) {</span>
<span class="fc" id="L395">            return false;</span>
        } else {
<span class="fc bfc" id="L397" title="All 2 branches covered.">            return node == childAfter(parent);</span>
        }
    }

    /** Find the child node just before an internal node.
     * @param node internal node at which the sub-tree starts
     * @return child node just before the internal node
     */
    private BSPTree&lt;Sphere1D&gt; childBefore(BSPTree&lt;Sphere1D&gt; node) {
<span class="fc bfc" id="L406" title="All 2 branches covered.">        if (isDirect(node)) {</span>
            // smaller angles are on minus side, larger angles are on plus side
<span class="fc" id="L408">            return node.getMinus();</span>
        } else {
            // smaller angles are on plus side, larger angles are on minus side
<span class="fc" id="L411">            return node.getPlus();</span>
        }
    }

    /** Find the child node just after an internal node.
     * @param node internal node at which the sub-tree starts
     * @return child node just after the internal node
     */
    private BSPTree&lt;Sphere1D&gt; childAfter(BSPTree&lt;Sphere1D&gt; node) {
<span class="fc bfc" id="L420" title="All 2 branches covered.">        if (isDirect(node)) {</span>
            // smaller angles are on minus side, larger angles are on plus side
<span class="fc" id="L422">            return node.getPlus();</span>
        } else {
            // smaller angles are on plus side, larger angles are on minus side
<span class="fc" id="L425">            return node.getMinus();</span>
        }
    }

    /** Check if an internal node has a direct limit angle.
     * @param node internal node to check
     * @return true if the limit angle is direct
     */
    private boolean isDirect(final BSPTree&lt;Sphere1D&gt; node) {
<span class="fc" id="L434">        return ((LimitAngle) node.getCut().getHyperplane()).isDirect();</span>
    }

    /** Get the limit angle of an internal node.
     * @param node internal node to check
     * @return limit angle
     */
    private double getAngle(final BSPTree&lt;Sphere1D&gt; node) {
<span class="fc" id="L442">        return ((LimitAngle) node.getCut().getHyperplane()).getLocation().getAlpha();</span>
    }

    /** {@inheritDoc} */
    @Override
    public ArcsSet buildNew(final BSPTree&lt;Sphere1D&gt; tree) {
<span class="fc" id="L448">        return new ArcsSet(tree, getTolerance());</span>
    }

    /** {@inheritDoc} */
    @Override
    protected void computeGeometricalProperties() {
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (getTree(false).getCut() == null) {</span>
<span class="fc" id="L455">            setBarycenter(S1Point.NaN);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">            setSize(((Boolean) getTree(false).getAttribute()) ? MathUtils.TWO_PI : 0);</span>
<span class="fc" id="L457">        } else {</span>
<span class="fc" id="L458">            double size = 0.0;</span>
<span class="fc" id="L459">            double sum  = 0.0;</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">            for (final double[] a : this) {</span>
<span class="fc" id="L461">                final double length = a[1] - a[0];</span>
<span class="fc" id="L462">                size += length;</span>
<span class="fc" id="L463">                sum  += length * (a[0] + a[1]);</span>
            }
<span class="fc" id="L465">            setSize(size);</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">            if (Precision.equals(size, MathUtils.TWO_PI, 0)) {</span>
<span class="nc" id="L467">                setBarycenter(S1Point.NaN);</span>
<span class="pc bfc" id="L468" title="All 2 branches covered.">            } else if (size &gt;= Precision.SAFE_MIN) {</span>
<span class="fc" id="L469">                setBarycenter(new S1Point(sum / (2 * size)));</span>
<span class="fc" id="L470">            } else {</span>
<span class="fc" id="L471">                final LimitAngle limit = (LimitAngle) getTree(false).getCut().getHyperplane();</span>
<span class="fc" id="L472">                setBarycenter(limit.getLocation());</span>
            }
        }
<span class="fc" id="L475">    }</span>

    /** {@inheritDoc}
     * @since 3.3
     */
    @Override
    public BoundaryProjection&lt;Sphere1D&gt; projectToBoundary(final Point&lt;Sphere1D&gt; point) {

        // get position of test point
<span class="fc" id="L484">        final double alpha = ((S1Point) point).getAlpha();</span>

<span class="fc" id="L486">        boolean wrapFirst = false;</span>
<span class="fc" id="L487">        double first      = Double.NaN;</span>
<span class="fc" id="L488">        double previous   = Double.NaN;</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">        for (final double[] a : this) {</span>

<span class="pc bpc" id="L491" title="1 of 2 branches missed.">            if (Double.isNaN(first)) {</span>
                // remember the first angle in case we need it later
<span class="fc" id="L493">                first = a[0];</span>
            }

<span class="pc bpc" id="L496" title="1 of 2 branches missed.">            if (!wrapFirst) {</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">                if (alpha &lt; a[0]) {</span>
                    // the test point lies between the previous and the current arcs
                    // offset will be positive
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">                    if (Double.isNaN(previous)) {</span>
                        // we need to wrap around the circle
<span class="fc" id="L502">                        wrapFirst = true;</span>
<span class="fc" id="L503">                    } else {</span>
<span class="nc" id="L504">                        final double previousOffset = alpha - previous;</span>
<span class="nc" id="L505">                        final double currentOffset  = a[0] - alpha;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                        if (previousOffset &lt; currentOffset) {</span>
<span class="nc" id="L507">                            return new BoundaryProjection&lt;Sphere1D&gt;(point, new S1Point(previous), previousOffset);</span>
                        } else {
<span class="nc" id="L509">                            return new BoundaryProjection&lt;Sphere1D&gt;(point, new S1Point(a[0]), currentOffset);</span>
                        }
                    }
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">                } else if (alpha &lt;= a[1]) {</span>
                    // the test point lies within the current arc
                    // offset will be negative
<span class="nc" id="L515">                    final double offset0 = a[0] - alpha;</span>
<span class="nc" id="L516">                    final double offset1 = alpha - a[1];</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                    if (offset0 &lt; offset1) {</span>
<span class="nc" id="L518">                        return new BoundaryProjection&lt;Sphere1D&gt;(point, new S1Point(a[1]), offset1);</span>
                    } else {
<span class="nc" id="L520">                        return new BoundaryProjection&lt;Sphere1D&gt;(point, new S1Point(a[0]), offset0);</span>
                    }
                }
            }
<span class="fc" id="L524">            previous = a[1];</span>
        }

<span class="pc bpc" id="L527" title="1 of 2 branches missed.">        if (Double.isNaN(previous)) {</span>

            // there are no points at all in the arcs set
<span class="nc" id="L530">            return new BoundaryProjection&lt;Sphere1D&gt;(point, null, MathUtils.TWO_PI);</span>

        } else {

            // the test point if before first arc and after last arc,
            // somewhere around the 0/2 \pi crossing
<span class="fc bfc" id="L536" title="All 2 branches covered.">            if (wrapFirst) {</span>
                // the test point is between 0 and first
<span class="fc" id="L538">                final double previousOffset = alpha - (previous - MathUtils.TWO_PI);</span>
<span class="fc" id="L539">                final double currentOffset  = first - alpha;</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">                if (previousOffset &lt; currentOffset) {</span>
<span class="fc" id="L541">                    return new BoundaryProjection&lt;Sphere1D&gt;(point, new S1Point(previous), previousOffset);</span>
                } else {
<span class="fc" id="L543">                    return new BoundaryProjection&lt;Sphere1D&gt;(point, new S1Point(first), currentOffset);</span>
                }
            } else {
                // the test point is between last and 2\pi
<span class="fc" id="L547">                final double previousOffset = alpha - previous;</span>
<span class="fc" id="L548">                final double currentOffset  = first + MathUtils.TWO_PI - alpha;</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">                if (previousOffset &lt; currentOffset) {</span>
<span class="fc" id="L550">                    return new BoundaryProjection&lt;Sphere1D&gt;(point, new S1Point(previous), previousOffset);</span>
                } else {
<span class="fc" id="L552">                    return new BoundaryProjection&lt;Sphere1D&gt;(point, new S1Point(first), currentOffset);</span>
                }
            }

        }

    }

    /** Build an ordered list of arcs representing the instance.
     * &lt;p&gt;This method builds this arcs set as an ordered list of
     * {@link Arc Arc} elements. An empty tree will build an empty list
     * while a tree representing the whole circle will build a one
     * element list with bounds set to \( 0 and 2 \pi \).&lt;/p&gt;
     * @return a new ordered list containing {@link Arc Arc} elements
     */
    public List&lt;Arc&gt; asList() {
<span class="fc" id="L568">        final List&lt;Arc&gt; list = new ArrayList&lt;Arc&gt;();</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">        for (final double[] a : this) {</span>
<span class="fc" id="L570">            list.add(new Arc(a[0], a[1], getTolerance()));</span>
        }
<span class="fc" id="L572">        return list;</span>
    }

    /** {@inheritDoc}
     * &lt;p&gt;
     * The iterator returns the limit angles pairs of sub-arcs in trigonometric order.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The iterator does &lt;em&gt;not&lt;/em&gt; support the optional {@code remove} operation.
     * &lt;/p&gt;
     */
    public Iterator&lt;double[]&gt; iterator() {
<span class="fc" id="L584">        return new SubArcsIterator();</span>
    }

    /** Local iterator for sub-arcs. */
    private class SubArcsIterator implements Iterator&lt;double[]&gt; {

        /** Start of the first arc. */
        private final BSPTree&lt;Sphere1D&gt; firstStart;

        /** Current node. */
        private BSPTree&lt;Sphere1D&gt; current;

        /** Sub-arc no yet returned. */
        private double[] pending;

        /** Simple constructor.
         */
<span class="fc" id="L601">        public SubArcsIterator() {</span>

<span class="fc" id="L603">            firstStart = getFirstArcStart();</span>
<span class="fc" id="L604">            current    = firstStart;</span>

<span class="fc bfc" id="L606" title="All 2 branches covered.">            if (firstStart == null) {</span>
                // all the leaf tree nodes share the same inside/outside status
<span class="fc bfc" id="L608" title="All 2 branches covered.">                if ((Boolean) getFirstLeaf(getTree(false)).getAttribute()) {</span>
                    // it is an inside node, it represents the full circle
<span class="fc" id="L610">                    pending = new double[] {</span>
<span class="fc" id="L611">                        0, MathUtils.TWO_PI</span>
                    };
<span class="fc" id="L613">                } else {</span>
<span class="fc" id="L614">                    pending = null;</span>
                }
<span class="fc" id="L616">            } else {</span>
<span class="fc" id="L617">                selectPending();</span>
            }
<span class="fc" id="L619">        }</span>

        /** Walk the tree to select the pending sub-arc.
         */
        private void selectPending() {

            // look for the start of the arc
<span class="fc" id="L626">            BSPTree&lt;Sphere1D&gt; start = current;</span>
<span class="fc bfc" id="L627" title="All 4 branches covered.">            while (start != null &amp;&amp; !isArcStart(start)) {</span>
<span class="fc" id="L628">                start = nextInternalNode(start);</span>
            }

<span class="fc bfc" id="L631" title="All 2 branches covered.">            if (start == null) {</span>
                // we have exhausted the iterator
<span class="fc" id="L633">                current = null;</span>
<span class="fc" id="L634">                pending = null;</span>
<span class="fc" id="L635">                return;</span>
            }

            // look for the end of the arc
<span class="fc" id="L639">            BSPTree&lt;Sphere1D&gt; end = start;</span>
<span class="fc bfc" id="L640" title="All 4 branches covered.">            while (end != null &amp;&amp; !isArcEnd(end)) {</span>
<span class="fc" id="L641">                end = nextInternalNode(end);</span>
            }

<span class="fc bfc" id="L644" title="All 2 branches covered.">            if (end != null) {</span>

                // we have identified the arc
<span class="fc" id="L647">                pending = new double[] {</span>
<span class="fc" id="L648">                    getAngle(start), getAngle(end)</span>
                };

                // prepare search for next arc
<span class="fc" id="L652">                current = end;</span>

<span class="fc" id="L654">            } else {</span>

                // the final arc wraps around 2\pi, its end is before the first start
<span class="fc" id="L657">                end = firstStart;</span>
<span class="pc bpc" id="L658" title="1 of 4 branches missed.">                while (end != null &amp;&amp; !isArcEnd(end)) {</span>
<span class="fc" id="L659">                    end = previousInternalNode(end);</span>
                }
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">                if (end == null) {</span>
                    // this should never happen
<span class="nc" id="L663">                    throw new MathInternalError();</span>
                }

                // we have identified the last arc
<span class="fc" id="L667">                pending = new double[] {</span>
<span class="fc" id="L668">                    getAngle(start), getAngle(end) + MathUtils.TWO_PI</span>
                };

                // there won't be any other arcs
<span class="fc" id="L672">                current = null;</span>

            }

<span class="fc" id="L676">        }</span>

        /** {@inheritDoc} */
        public boolean hasNext() {
<span class="fc bfc" id="L680" title="All 2 branches covered.">            return pending != null;</span>
        }

        /** {@inheritDoc} */
        public double[] next() {
<span class="fc bfc" id="L685" title="All 2 branches covered.">            if (pending == null) {</span>
<span class="fc" id="L686">                throw new NoSuchElementException();</span>
            }
<span class="fc" id="L688">            final double[] next = pending;</span>
<span class="fc" id="L689">            selectPending();</span>
<span class="fc" id="L690">            return next;</span>
        }

        /** {@inheritDoc} */
        public void remove() {
<span class="fc" id="L695">            throw new UnsupportedOperationException();</span>
        }

    }

    /** Compute the relative position of the instance with respect
     * to an arc.
     * &lt;p&gt;
     * The {@link Side#MINUS} side of the arc is the one covered by the arc.
     * &lt;/p&gt;
     * @param arc arc to check instance against
     * @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH}
     * or {@link Side#HYPER}
     */
    public Side side(final Arc arc) {

<span class="fc" id="L711">        final double reference = FastMath.PI + arc.getInf();</span>
<span class="fc" id="L712">        final double arcLength = arc.getSup() - arc.getInf();</span>

<span class="fc" id="L714">        boolean inMinus = false;</span>
<span class="fc" id="L715">        boolean inPlus  = false;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">        for (final double[] a : this) {</span>
<span class="fc" id="L717">            final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();</span>
<span class="fc" id="L718">            final double arcOffset   = a[0] - syncedStart;</span>
<span class="fc" id="L719">            final double syncedEnd   = a[1] - arcOffset;</span>
<span class="fc bfc" id="L720" title="All 4 branches covered.">            if (syncedStart &lt;= arcLength - getTolerance() || syncedEnd &gt;= MathUtils.TWO_PI + getTolerance()) {</span>
<span class="fc" id="L721">                inMinus = true;</span>
            }
<span class="fc bfc" id="L723" title="All 2 branches covered.">            if (syncedEnd &gt;= arcLength + getTolerance()) {</span>
<span class="fc" id="L724">                inPlus = true;</span>
            }
        }

<span class="fc bfc" id="L728" title="All 2 branches covered.">        if (inMinus) {</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">            if (inPlus) {</span>
<span class="fc" id="L730">                return Side.BOTH;</span>
            } else {
<span class="fc" id="L732">                return Side.MINUS;</span>
            }
        } else {
<span class="fc bfc" id="L735" title="All 2 branches covered.">            if (inPlus) {</span>
<span class="fc" id="L736">                return Side.PLUS;</span>
            } else {
<span class="fc" id="L738">                return Side.HYPER;</span>
            }
        }

    }

    /** Split the instance in two parts by an arc.
     * @param arc splitting arc
     * @return an object containing both the part of the instance
     * on the plus side of the arc and the part of the
     * instance on the minus side of the arc
     */
    public Split split(final Arc arc) {

<span class="fc" id="L752">        final List&lt;Double&gt; minus = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L753">        final List&lt;Double&gt;  plus = new ArrayList&lt;Double&gt;();</span>

<span class="fc" id="L755">        final double reference = FastMath.PI + arc.getInf();</span>
<span class="fc" id="L756">        final double arcLength = arc.getSup() - arc.getInf();</span>

<span class="fc bfc" id="L758" title="All 2 branches covered.">        for (final double[] a : this) {</span>
<span class="fc" id="L759">            final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();</span>
<span class="fc" id="L760">            final double arcOffset   = a[0] - syncedStart;</span>
<span class="fc" id="L761">            final double syncedEnd   = a[1] - arcOffset;</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">            if (syncedStart &lt; arcLength) {</span>
                // the start point a[0] is in the minus part of the arc
<span class="fc" id="L764">                minus.add(a[0]);</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">                if (syncedEnd &gt; arcLength) {</span>
                    // the end point a[1] is past the end of the arc
                    // so we leave the minus part and enter the plus part
<span class="fc" id="L768">                    final double minusToPlus = arcLength + arcOffset;</span>
<span class="fc" id="L769">                    minus.add(minusToPlus);</span>
<span class="fc" id="L770">                    plus.add(minusToPlus);</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">                    if (syncedEnd &gt; MathUtils.TWO_PI) {</span>
                        // in fact the end point a[1] goes far enough that we
                        // leave the plus part of the arc and enter the minus part again
<span class="fc" id="L774">                        final double plusToMinus = MathUtils.TWO_PI + arcOffset;</span>
<span class="fc" id="L775">                        plus.add(plusToMinus);</span>
<span class="fc" id="L776">                        minus.add(plusToMinus);</span>
<span class="fc" id="L777">                        minus.add(a[1]);</span>
<span class="fc" id="L778">                    } else {</span>
                        // the end point a[1] is in the plus part of the arc
<span class="fc" id="L780">                        plus.add(a[1]);</span>
                    }
<span class="fc" id="L782">                } else {</span>
                    // the end point a[1] is in the minus part of the arc
<span class="fc" id="L784">                    minus.add(a[1]);</span>
                }
<span class="fc" id="L786">            } else {</span>
                // the start point a[0] is in the plus part of the arc
<span class="fc" id="L788">                plus.add(a[0]);</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">                if (syncedEnd &gt; MathUtils.TWO_PI) {</span>
                    // the end point a[1] wraps around to the start of the arc
                    // so we leave the plus part and enter the minus part
<span class="fc" id="L792">                    final double plusToMinus = MathUtils.TWO_PI + arcOffset;</span>
<span class="fc" id="L793">                    plus.add(plusToMinus);</span>
<span class="fc" id="L794">                    minus.add(plusToMinus);</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">                    if (syncedEnd &gt; MathUtils.TWO_PI + arcLength) {</span>
                        // in fact the end point a[1] goes far enough that we
                        // leave the minus part of the arc and enter the plus part again
<span class="fc" id="L798">                        final double minusToPlus = MathUtils.TWO_PI + arcLength + arcOffset;</span>
<span class="fc" id="L799">                        minus.add(minusToPlus);</span>
<span class="fc" id="L800">                        plus.add(minusToPlus);</span>
<span class="fc" id="L801">                        plus.add(a[1]);</span>
<span class="fc" id="L802">                    } else {</span>
                        // the end point a[1] is in the minus part of the arc
<span class="fc" id="L804">                        minus.add(a[1]);</span>
                    }
<span class="fc" id="L806">                } else {</span>
                    // the end point a[1] is in the plus part of the arc
<span class="fc" id="L808">                    plus.add(a[1]);</span>
                }
            }
        }

<span class="fc" id="L813">        return new Split(createSplitPart(plus), createSplitPart(minus));</span>

    }

    /** Add an arc limit to a BSP tree under construction.
     * @param tree BSP tree under construction
     * @param alpha arc limit
     * @param isStart if true, the limit is the start of an arc
     */
    private void addArcLimit(final BSPTree&lt;Sphere1D&gt; tree, final double alpha, final boolean isStart) {

<span class="fc bfc" id="L824" title="All 2 branches covered.">        final LimitAngle limit = new LimitAngle(new S1Point(alpha), !isStart, getTolerance());</span>
<span class="fc" id="L825">        final BSPTree&lt;Sphere1D&gt; node = tree.getCell(limit.getLocation(), getTolerance());</span>
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">        if (node.getCut() != null) {</span>
            // this should never happen
<span class="nc" id="L828">            throw new MathInternalError();</span>
        }

<span class="fc" id="L831">        node.insertCut(limit);</span>
<span class="fc" id="L832">        node.setAttribute(null);</span>
<span class="fc" id="L833">        node.getPlus().setAttribute(Boolean.FALSE);</span>
<span class="fc" id="L834">        node.getMinus().setAttribute(Boolean.TRUE);</span>

<span class="fc" id="L836">    }</span>

    /** Create a split part.
     * &lt;p&gt;
     * As per construction, the list of limit angles is known to have
     * an even number of entries, with start angles at even indices and
     * end angles at odd indices.
     * &lt;/p&gt;
     * @param limits limit angles of the split part
     * @return split part (may be null)
     */
    private ArcsSet createSplitPart(final List&lt;Double&gt; limits) {
<span class="fc bfc" id="L848" title="All 2 branches covered.">        if (limits.isEmpty()) {</span>
<span class="fc" id="L849">            return null;</span>
        } else {

            // collapse close limit angles
<span class="fc bfc" id="L853" title="All 2 branches covered.">            for (int i = 0; i &lt; limits.size(); ++i) {</span>
<span class="fc" id="L854">                final int    j  = (i + 1) % limits.size();</span>
<span class="fc" id="L855">                final double lA = limits.get(i);</span>
<span class="fc" id="L856">                final double lB = MathUtils.normalizeAngle(limits.get(j), lA);</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">                if (FastMath.abs(lB - lA) &lt;= getTolerance()) {</span>
                    // the two limits are too close to each other, we remove both of them
<span class="fc bfc" id="L859" title="All 2 branches covered.">                    if (j &gt; 0) {</span>
                        // regular case, the two entries are consecutive ones
<span class="fc" id="L861">                        limits.remove(j);</span>
<span class="fc" id="L862">                        limits.remove(i);</span>
<span class="fc" id="L863">                        i = i - 1;</span>
<span class="fc" id="L864">                    } else {</span>
                        // special case, i the the last entry and j is the first entry
                        // we have wrapped around list end
<span class="fc" id="L867">                        final double lEnd   = limits.remove(limits.size() - 1);</span>
<span class="fc" id="L868">                        final double lStart = limits.remove(0);</span>
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">                        if (limits.isEmpty()) {</span>
                            // the ends were the only limits, is it a full circle or an empty circle?
<span class="nc bnc" id="L871" title="All 2 branches missed.">                            if (lEnd - lStart &gt; FastMath.PI) {</span>
                                // it was full circle
<span class="nc" id="L873">                                return new ArcsSet(new BSPTree&lt;Sphere1D&gt;(Boolean.TRUE), getTolerance());</span>
                            } else {
                                // it was an empty circle
<span class="nc" id="L876">                                return null;</span>
                            }
                        } else {
                            // we have removed the first interval start, so our list
                            // currently starts with an interval end, which is wrong
                            // we need to move this interval end to the end of the list
<span class="fc" id="L882">                            limits.add(limits.remove(0) + MathUtils.TWO_PI);</span>
                        }
                    }
                }
            }

            // build the tree by adding all angular sectors
<span class="fc" id="L889">            BSPTree&lt;Sphere1D&gt; tree = new BSPTree&lt;Sphere1D&gt;(Boolean.FALSE);</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">            for (int i = 0; i &lt; limits.size() - 1; i += 2) {</span>
<span class="fc" id="L891">                addArcLimit(tree, limits.get(i),     true);</span>
<span class="fc" id="L892">                addArcLimit(tree, limits.get(i + 1), false);</span>
            }

<span class="fc bfc" id="L895" title="All 2 branches covered.">            if (tree.getCut() == null) {</span>
                // we did not insert anything
<span class="fc" id="L897">                return null;</span>
            }

<span class="fc" id="L900">            return new ArcsSet(tree, getTolerance());</span>

        }
    }

    /** Class holding the results of the {@link #split split} method.
     */
    public static class Split {

        /** Part of the arcs set on the plus side of the splitting arc. */
        private final ArcsSet plus;

        /** Part of the arcs set on the minus side of the splitting arc. */
        private final ArcsSet minus;

        /** Build a Split from its parts.
         * @param plus part of the arcs set on the plus side of the
         * splitting arc
         * @param minus part of the arcs set on the minus side of the
         * splitting arc
         */
<span class="fc" id="L921">        private Split(final ArcsSet plus, final ArcsSet minus) {</span>
<span class="fc" id="L922">            this.plus  = plus;</span>
<span class="fc" id="L923">            this.minus = minus;</span>
<span class="fc" id="L924">        }</span>

        /** Get the part of the arcs set on the plus side of the splitting arc.
         * @return part of the arcs set on the plus side of the splitting arc
         */
        public ArcsSet getPlus() {
<span class="fc" id="L930">            return plus;</span>
        }

        /** Get the part of the arcs set on the minus side of the splitting arc.
         * @return part of the arcs set on the minus side of the splitting arc
         */
        public ArcsSet getMinus() {
<span class="fc" id="L937">            return minus;</span>
        }

    }

    /** Specialized exception for inconsistent BSP tree state inconsistency.
     * &lt;p&gt;
     * This exception is thrown at {@link ArcsSet} construction time when the
     * {@link org.apache.commons.math3.geometry.partitioning.Region.Location inside/outside}
     * state is not consistent at the 0, \(2 \pi \) crossing.
     * &lt;/p&gt;
     */
    public static class InconsistentStateAt2PiWrapping extends MathIllegalArgumentException {

        /** Serializable UID. */
        private static final long serialVersionUID = 20140107L;

        /** Simple constructor.
         */
        public InconsistentStateAt2PiWrapping() {
<span class="fc" id="L957">            super(LocalizedFormats.INCONSISTENT_STATE_AT_2_PI_WRAPPING);</span>
<span class="fc" id="L958">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>